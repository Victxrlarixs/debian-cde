---
import WindowControls from '../../common/WindowControls.astro';
import WindowMinimize from '../../common/WindowMinimize.astro';
import XPM_BACKDROPS from '../../../data/backdrops.json';
---

<div class="cde-retro-modal" id="styleManagerBackdrop">
  <div
    class="titlebar"
    id="styleManagerBackdropTitlebar"
    onmousedown="window.drag(event, 'styleManagerBackdrop')"
  >
    <WindowMinimize windowId="styleManagerBackdrop" />
    <span class="titlebar-text">Style Manager - Backdrop</span>
    <WindowControls
      windowId="styleManagerBackdrop"
      closeFunction="styleManager.closeBackdrop"
      disableMaximize={true}
    />
  </div>

  <div class="modal-body backdrop-modal-body">
    <p class="backdrop-section-label">Classic CDE Patterns</p>
    <div class="backdrop-grid" id="backdropXpmGrid">
      {
        XPM_BACKDROPS.map((bd) => (
          <button
            class="backdrop-preset"
            data-type="xpm"
            data-value={`/backdrops/${bd.file}`}
            onclick={`styleManager.backdrop.update('xpm', '/backdrops/${bd.file}'); styleManager.backdrop.syncUI()`}
            title={bd.name}
          >
            <canvas
              class="backdrop-preview-canvas"
              data-xpm={`/backdrops/${bd.file}`}
              width="48"
              height="36"
            />
            <span class="backdrop-label">{bd.name}</span>
          </button>
        ))
      }
    </div>
  </div>

  <div class="cde-statusbar">
    <div class="cde-statusleft">Backdrop</div>
    <div class="cde-statusright" id="backdropStatus">Ready</div>
  </div>

  <div class="cde-actionbar">
    <button class="cde-btn cde-btn-default" onclick="styleManager.closeBackdrop()">OK</button>
    <button class="cde-btn" onclick="styleManager.closeBackdrop()">Cancel</button>
    <button class="cde-btn" onclick="styleManager.showMessage('Help not implemented')">Help</button>
  </div>
</div>

<script>
  import { parseXpmToDataUrl } from '../../../scripts/core/xpmparser';

  const thumbnailCache = new Map<string, string>();

  async function renderThumbnail(canvas: HTMLCanvasElement) {
    if (canvas.dataset.rendered || canvas.dataset.loading) return;
    canvas.dataset.loading = 'true';

    const path = canvas.dataset.xpm!;
    try {
      let dataUrl = thumbnailCache.get(path);

      if (!dataUrl) {
        const res = await fetch(path);
        if (!res.ok) throw new Error('Fetch failed');
        const text = await res.text();
        dataUrl = (await parseXpmToDataUrl(text)) ?? undefined;
        if (dataUrl) thumbnailCache.set(path, dataUrl);
      }

      if (dataUrl) {
        const img = new Image();
        img.onload = () => {
          const ctx = canvas.getContext('2d');
          if (ctx) {
            const pat = ctx.createPattern(img, 'repeat');
            if (pat) {
              ctx.fillStyle = pat;
              ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
          }
          canvas.dataset.rendered = '1';
          delete canvas.dataset.loading;
        };
        img.src = dataUrl;
      }
    } catch {
      delete canvas.dataset.loading;
    }
  }

  function setupIntersectionObserver() {
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            renderThumbnail(entry.target as HTMLCanvasElement);
          }
        });
      },
      {
        root: document.querySelector('.backdrop-modal-body'),
        rootMargin: '100px', // Pre-load thumbnails before they enter view
        threshold: 0.1,
      }
    );

    document.querySelectorAll('.backdrop-preview-canvas').forEach((canvas) => {
      observer.observe(canvas);
    });
  }

  document.addEventListener('DOMContentLoaded', () => {
    const modal = document.getElementById('styleManagerBackdrop');
    if (!modal) return;

    const observer = new MutationObserver(() => {
      if (modal.offsetParent !== null) {
        setupIntersectionObserver();
      }
    });

    observer.observe(modal, { attributes: true, attributeFilter: ['style', 'class'] });
    if (modal.offsetParent !== null) setupIntersectionObserver();
  });
</script>
